#!/bin/bash
#
# Copyright (C) 2019 Philippe Proulx <pproulx@efficios.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; only version 2
# of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

# This test validates that a `src.ctf.fs` component successfully reads
# specific CTF traces and creates the expected messages.
#
# Such CTF traces to open either exist (in `tests/ctf-traces/succeed`)
# or are generated by this test using local trace generators.

SH_TAP=1

if [ "x${BT_TESTS_SRCDIR:-}" != "x" ]; then
	UTILSSH="$BT_TESTS_SRCDIR/utils/utils.sh"
else
	UTILSSH="$(dirname "$0")/../../utils/utils.sh"
fi

# shellcheck source=../../utils/utils.sh
source "$UTILSSH"

function cleanup ()
{
	# Disable trap for SIGTERM since the following kill to the
	# pidgroup will be SIGTERM. Otherwise it loops.
	# The '-' before the pid number ($$) indicates 'kill' to signal the
	# whole process group.
	trap - SIGTERM && kill -- -$$
}

# Ensure that background child jobs are killed on SIGINT/SIGTERM
trap cleanup SIGINT SIGTERM

this_dir_relative="plugins/src.ctf.lttng-live"
test_data_dir="$BT_TESTS_DATADIR/$this_dir_relative"
trace_dir="$BT_CTF_TRACES_PATH/$this_dir_relative"

lttng_live_server() {
	local temp_port_file="$1"
	local port_file="$2"
	local retcode_file="$3"
	local pid_file="$4"
	local server_args="$5"
	local server_script="$test_data_dir/lttng_live_server.py"

	# start server
	echo "$server_args" | xargs "$BT_TESTS_PYTHON_BIN" "$server_script" --tmp-port-file "$temp_port_file" --port-file "$port_file" &

	# write PID to file
	echo $! > "$pid_file"

	# wait for server to exit
	wait

	# write return code to file
	echo $? > "$retcode_file"
}

kill_lttng_live_server() {
	local pid_file="$1"

	if [ ! -s "$pid_file" ]; then
		return
	fi

	kill -9 "$(<"$pid_file")"
}

get_cli_output_with_lttng_live_server() {
	local cli_args_template="$1"
	local server_args="$2"
	local cli_stdout_file="$3"
	local cli_stderr_file="$4"
	local port_file="$5"

	local i
	local ret
	local port
	local cli_args
	local server_pid_file
	local server_retcode_file
	local temp_port_file

	temp_port_file="$(mktemp)"
	server_pid_file="$(mktemp)"
	server_retcode_file="$(mktemp)"

	diag "Starting LTTng live server mockup"

	# This starts the server, which eventually writes its listening
	# port number to the `$port_file` file. The lttng_live_server()
	# function itself writes the server's PID to the
	# `$server_pid_file` file. When the server exits,
	# lttng_live_server() writes its return code to the
	# `$server_retcode_file` file.
	lttng_live_server "$temp_port_file" "$port_file" \
		"$server_pid_file" "$server_retcode_file" "$server_args" &


	# get port number
	i=0

	while [ ! -s "$port_file" ]; do
		sleep .1

		if [ "$i" -eq "100" ]; then
			# too long, kill it
			kill_lttng_live_server "$server_pid_file"
			wait
			rm -f "$temp_port_file"
			rm -f "$server_pid_file"
			rm -f "$server_retcode_file"
			return 1
		fi

		i=$((i + 1))
	done

	port=$(<"$port_file")

	diag "LTTng live port is $port"

	cli_args=${cli_args_template//@PORT@/$port}

	diag "Running CLI: 'babeltrace2 $cli_args'"
	if echo "$cli_args" | xargs "$BT_TESTS_BT2_BIN" 1>"$cli_stdout_file" 2>"$cli_stderr_file"; then
		# CLI failed: cancel everything else
		kill_lttng_live_server "$server_pid_file"
		wait
		rm -f "$temp_port_file"
		rm -f "$server_pid_file"
		rm -f "$server_retcode_file"
		return 1
	fi

	# get server's return code
	i=0

	while [ ! -s "$server_retcode_file" ]; do
		sleep .1

		if [ "$i" -eq "100" ]; then
			# too long, kill it
			kill_lttng_live_server "$server_pid_file"
			wait
			rm -f "$temp_port_file"
			rm -f "$server_pid_file"
			rm -f "$server_retcode_file"
			return 1
		fi

		i=$((i + 1))
	done

	wait

	ret=$(<"$server_retcode_file")

	rm -f "$temp_port_file"
	rm -f "$server_pid_file"
	rm -f "$server_retcode_file"
	return "$ret"
}

test_list_sessions() {
	# Test the basic listing of sessions.
	# Ensure that a multi-domain trace is seen as a single session.

	local port
	local temp_port_file
	local port_file
	local tmp_stdout_expected

	local test_text="CLI prints the expected session list"
	local template_expected=$(<"$test_data_dir/cli-list-sessions.expect")
	local cli_args_template="-i lttng-live net://localhost:@PORT@"
	local server_args="'multi-domains,0,hostname,1,0,${trace_dir}/multi-domains/kernel/,${trace_dir}/multi-domains/ust/' 'trace-with-index,1,hostname,1,0,${trace_dir}/trace-with-index/'"

	cli_stderr="$(mktemp)"
	cli_stdout="$(mktemp)"
	empty_file="$(mktemp)"
	port_file="$(mktemp)"
	tmp_stdout_expected="$(mktemp)"

	get_cli_output_with_lttng_live_server "$cli_args_template" "$server_args" "$cli_stdout" "$cli_stderr" "$port_file"
	port=$(<"$port_file")

	# Craft the expected output. This is necessary since the port number
	# (random) of a "relayd" is present in the output.
	template_expected=${template_expected//@PORT@/$port}

	echo "$template_expected" > "$tmp_stdout_expected"

	bt_diff "$tmp_stdout_expected" "$cli_stdout" "$empty_file" "$cli_stderr" "$cli_args_template"
	ok $? "$test_text"
	rm -rf "$cli_stderr"
	rm -rf "$cli_stdout"
	rm -rf "$empty_file"
	rm -rf "$port_file"
	rm -rf "$tmp_stdout_expected"
}

test_base() {
	# Attach and consume data from a multi packets ust session with no
	# discarded events.

	local port
	local temp_port_file
	local port_file
	local tmp_stdout_expected
	local server_args

	local test_text="CLI attach and fetch from single-domains session - no discarded events"
	local cli_args_template="-i lttng-live net://localhost:@PORT@/host/hostname/trace-with-index -c sink.text.details"
	local server_args="'trace-with-index,0,hostname,1,0,${trace_dir}/trace-with-index/'"

	cli_stderr="$(mktemp)"
	cli_stdout="$(mktemp)"
	empty_file="$(mktemp)"
	port_file="$(mktemp)"
	tmp_stdout_expected="$(mktemp)"

	get_cli_output_with_lttng_live_server "$cli_args_template" "$server_args" "$cli_stdout" "$cli_stderr" "$port_file"
	port=$(<"$port_file")

	bt_diff "${test_data_dir}/cli-base.expect" "$cli_stdout" "$empty_file" "$cli_stderr" "$cli_args_template"
	ok $? "$test_text"

	rm -rf "$cli_stderr"
	rm -rf "$cli_stdout"
	rm -rf "$port_file"
	rm -rf "$tmp_stdout_expected"
}

test_multi_domains() {
	# Attach and consume data from a multi-domains session with discarded
	# events.

	local port
	local temp_port_file
	local port_file
	local tmp_stdout_expected
	local server_args

	local test_text="CLI attach and fetch from multi-domains session - discarded events"
	local cli_args_template="-i lttng-live net://localhost:@PORT@/host/hostname/multi-domains -c sink.text.details"
	local server_args="'multi-domains,0,hostname,1,0,${trace_dir}/multi-domains/kernel/,${trace_dir}/multi-domains/ust/'"

	cli_stderr="$(mktemp)"
	cli_stdout="$(mktemp)"
	empty_file="$(mktemp)"
	port_file="$(mktemp)"
	tmp_stdout_expected="$(mktemp)"

	get_cli_output_with_lttng_live_server "$cli_args_template" "$server_args" "$cli_stdout" "$cli_stderr" "$port_file"
	port=$(<"$port_file")

	bt_diff "${test_data_dir}/cli-multi-domains.expect" "$cli_stdout" "$empty_file" "$cli_stderr" "$cli_args_template"
	ok $? "$test_text"

	rm -rf "$cli_stderr"
	rm -rf "$cli_stdout"
	rm -rf "$port_file"
	rm -rf "$tmp_stdout_expected"
}

plan_tests 3

test_list_sessions
test_base
test_multi_domains
